<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Counter</title>
  <style>
    :root{
      --bg:#0b0f14;
      --text:#ffffff;

      --green:#0f8a3a;
      --green-border:#46d86b;
      --green-plus:#8dffb0;

      --orange:#c06a00;
      --orange-border:#ffb15a;
      --orange-icon:#ffd2a2;

      --gray:#3a4656;
      --gray-border:#a3b0c0;
      --gray-icon:#d0dae6;

      --red:#a81616;
      --red-border:#ff7272;
      --red-icon:#ffb3b3;

      --small:56px;
      --big:210px;

      --shadow-outer: 0 14px 26px rgba(0,0,0,.55);
      --shadow-inner: inset 0 1px 0 rgba(255,255,255,.25), inset 0 -6px 14px rgba(0,0,0,.35);
    }

    *{
      box-sizing:border-box;
      -webkit-tap-highlight-color: transparent;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
    }

    html, body{ height:100%; }

    body{
      margin:0;
      display:grid;
      place-items:center;
      background: radial-gradient(1200px 700px at 50% 20%, #182437 0%, var(--bg) 55%, #070a0e 100%);
      color:var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      overscroll-behavior:none;
      touch-action: manipulation;
    }

    .phone{
      width:min(390px, 100vw);
      height:min(844px, 100vh);
      padding: 22px 18px 22px;
      border-radius: 42px;
      background: linear-gradient(180deg, rgba(255,255,255,.06) 0%, rgba(255,255,255,.02) 30%, rgba(0,0,0,.10) 100%);
      box-shadow: 0 30px 70px rgba(0,0,0,.65);
      border: 1px solid rgba(255,255,255,.08);
      position:relative;
      overflow:hidden;
    }

    .safe-top{ height: 14px; margin-bottom: 6px; opacity:.6; }

    .wrap{
      height: calc(100% - 20px);
      display:flex;
      flex-direction:column;
      justify-content:center;
      gap: 16px;
      padding-bottom: 10px;
    }

    /* Max slider row */
    .maxRow{
      width: var(--big);
      margin: 0 auto;
      display:flex;
      flex-direction:column;
      gap: 6px;
    }

    .maxHeader{
      display:flex;
      justify-content:space-between;
      align-items:center;
      font-size:14px;
      font-weight:700;
      opacity:.9;
    }

    .maxValue{
      font-size:18px;
      font-weight:800;
      letter-spacing:.4px;
    }

    input[type=range]{
      -webkit-appearance:none;
      width:100%;
      height:10px;
      border-radius:999px;
      background: rgba(255,255,255,.08);
      outline:none;
      box-shadow: inset 0 2px 8px rgba(0,0,0,.45);
    }

    input[type=range]::-webkit-slider-thumb{
      -webkit-appearance:none;
      width:28px;
      height:28px;
      border-radius:50%;
      background: linear-gradient(180deg, #ffffff 0%, #dfe6ef 100%);
      border:3px solid var(--gray-border);
      box-shadow: 0 10px 18px rgba(0,0,0,.45);
    }

    input[type=range]::-moz-range-thumb{
      width:28px;
      height:28px;
      border-radius:50%;
      background:#ffffff;
      border:3px solid var(--gray-border);
    }

    /* Controls row */
    .controlsRow{
      width: var(--big);
      margin: 0 auto;
      display:flex;
      align-items:center;
      justify-content:space-between;
    }

    .count{
      font-size:64px;
      font-weight:800;
      text-align:center;
      text-shadow: 0 10px 24px rgba(0,0,0,.55);
    }

    button{
      font: inherit;
      border:none;
      background:none;
      color:inherit;
      -webkit-appearance:none;
      appearance:none;
      padding:0;
    }

    .btn{
      width: var(--small);
      height: var(--small);
      border-radius:14px;
      border:3px solid transparent;
      box-shadow: var(--shadow-outer), var(--shadow-inner);
      display:grid;
      place-items:center;
      cursor:pointer;
      transform: translateZ(0);
    }

    .btn *{ pointer-events:none; }

    .btn:active{ transform: translateY(1px); filter: brightness(.98); }

    .btn.big{ width:var(--big); height:var(--big); border-radius:26px; }

    .btn.orange{ background:linear-gradient(180deg,#e47a00,var(--orange)); border-color:var(--orange-border); }
    .btn.gray{ background:linear-gradient(180deg,#566276,var(--gray)); border-color:var(--gray-border); }
    .btn.red{ background:linear-gradient(180deg,#d11f1f,var(--red)); border-color:var(--red-border); }
    .btn.green{ background:linear-gradient(180deg,#14a046,var(--green)); border-color:var(--green-border); }

    .minus{ font-size:34px; font-weight:900; color:var(--orange-icon); transform: translateY(-1px); }
    .runnerIcon{ font-size:22px; filter: drop-shadow(0 4px 10px rgba(0,0,0,.35)); }
    .soundIcon{ font-size:22px; }
    .trashIcon{ font-size:22px; }
    .plus{ font-size:112px; font-weight:900; color:var(--green-plus); transform: translateY(-4px); }

    .hint{ font-size:13px; text-align:center; opacity:.75; }

    .btn:focus-visible{ outline: 3px solid rgba(255,255,255,.55); outline-offset: 3px; }
  </style>
</head>
<body>
  <div class="phone" role="application" aria-label="Counter app">
    <div class="safe-top"></div>

    <div class="wrap">
      <!-- Max slider -->
      <div class="maxRow" aria-label="Maximum count">
        <div class="maxHeader">
          <span>Max</span>
          <span id="maxValue" class="maxValue">10000</span>
        </div>
        <input id="maxSlider" type="range" min="0" max="100000" step="100" value="10000" />
      </div>

      <!-- Controls -->
      <div class="controlsRow" aria-label="Controls">
        <button id="minusBtn" class="btn orange" aria-label="Minus" draggable="false">
          <span class="minus">‚àí</span>
        </button>
        <button id="speedBtn" class="btn gray" aria-label="Speed" draggable="false">
          <span class="runnerIcon" aria-hidden="true">üèÉ</span>
        </button>
        <button id="soundBtn" class="btn gray" aria-label="Sound on" draggable="false">
          <span id="soundIcon" class="soundIcon" aria-hidden="true">üîä</span>
        </button>
        <button id="resetBtn" class="btn red" aria-label="Reset" draggable="false">
          <span class="trashIcon" aria-hidden="true">üóë</span>
        </button>
      </div>

      <div id="count" class="count" aria-live="polite">0</div>

      <div style="display:flex;justify-content:center;">
        <button id="plusBtn" class="btn big green" aria-label="Plus" draggable="false">
          <span class="plus">+</span>
        </button>
      </div>

      <div id="hint" class="hint">Max: 10000 ¬∑ Rate: 10/sec</div>
    </div>
  </div>

  <script>
    // ====== Behavior targets ======
    // - Hold +/- for continuous counting (starts after 1/3s)
    // - Speed button: tap slows down, hold accelerates toward 1000/sec
    // - Sound button toggles icon and click sound
    // - Max slider clamps the counter

    // ====== State ======
    let value = 0;
    let maxValue = 10000;

    const RATE_MIN = 1;
    const RATE_MAX = 1000; // requested max
    let ratePerSec = 10;   // requested default

    const HOLD_THRESHOLD_MS = 333;

    // ====== Elements ======
    const countEl = document.getElementById('count');
    const hintEl = document.getElementById('hint');

    const maxValueEl = document.getElementById('maxValue');
    const maxSlider = document.getElementById('maxSlider');

    const plusBtn = document.getElementById('plusBtn');
    const minusBtn = document.getElementById('minusBtn');
    const speedBtn = document.getElementById('speedBtn');
    const soundBtn = document.getElementById('soundBtn');
    const soundIcon = document.getElementById('soundIcon');
    const resetBtn = document.getElementById('resetBtn');

    // ====== No-selection hardening for iOS ======
    document.addEventListener('contextmenu', (e) => e.preventDefault());
    document.addEventListener('selectstart', (e) => e.preventDefault());

    // ====== UI ======
    function updateHint(){
      hintEl.textContent = `Max: ${maxValue} ¬∑ Rate: ${ratePerSec}/sec`;
    }

    function setValue(next){
      value = next;
      if (value > maxValue) value = maxValue;
      countEl.textContent = String(value);
    }

    function setMaxValue(next){
      maxValue = Math.max(0, next);
      maxValueEl.textContent = String(maxValue);
      if (value > maxValue) setValue(maxValue);
      updateHint();
    }

    // ====== Sound (WebAudio + HTMLAudio fallback) ======
    let soundOn = true;
    let audioCtx = null;
    let audioUnlocked = false;

    let clickPool = [];
    let clickPoolIdx = 0;

    function ensureAudioContext(){
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      return audioCtx;
    }

    function pcmToWavUrl(samples, sampleRate){
      const numChannels = 1;
      const bitsPerSample = 16;
      const byteRate = sampleRate * numChannels * bitsPerSample / 8;
      const blockAlign = numChannels * bitsPerSample / 8;
      const dataSize = samples.length * 2;
      const buffer = new ArrayBuffer(44 + dataSize);
      const view = new DataView(buffer);

      const writeStr = (off, str) => { for (let i=0;i<str.length;i++) view.setUint8(off+i, str.charCodeAt(i)); };
      writeStr(0, 'RIFF');
      view.setUint32(4, 36 + dataSize, true);
      writeStr(8, 'WAVE');
      writeStr(12, 'fmt ');
      view.setUint32(16, 16, true);
      view.setUint16(20, 1, true);
      view.setUint16(22, numChannels, true);
      view.setUint32(24, sampleRate, true);
      view.setUint32(28, byteRate, true);
      view.setUint16(32, blockAlign, true);
      view.setUint16(34, bitsPerSample, true);
      writeStr(36, 'data');
      view.setUint32(40, dataSize, true);

      let o = 44;
      for (let i=0;i<samples.length;i++){
        view.setInt16(o, samples[i], true);
        o += 2;
      }
      const blob = new Blob([buffer], { type: 'audio/wav' });
      return URL.createObjectURL(blob);
    }

    function buildClickPool(){
      if (clickPool.length) return;

      // short click ~10ms
      const sr = 44100;
      const ms = 10;
      const n = Math.floor(sr * (ms/1000));
      const samples = new Int16Array(n);
      const f = 1900;
      for (let i=0;i<n;i++){
        const t = i / sr;
        const env = Math.exp(-t * 180);
        const s = Math.sign(Math.sin(2*Math.PI*f*t)) * env;
        samples[i] = Math.max(-1, Math.min(1, s)) * 22000;
      }

      const url = pcmToWavUrl(samples, sr);
      for (let i=0;i<10;i++){
        const a = new Audio(url);
        a.preload = 'auto';
        clickPool.push(a);
      }
    }

    async function unlockAudioOnce(){
      if (audioUnlocked) return;
      buildClickPool();

      try{
        const ctx = ensureAudioContext();
        if (ctx.state === 'suspended') await ctx.resume();

        // warm HTMLAudio inside gesture
        const a = clickPool[0];
        a.currentTime = 0;
        await a.play().catch(() => {});
        a.pause();
        a.currentTime = 0;

        audioUnlocked = true;
      }catch(_e){
        // ignore
      }
    }

    // Keep click sound audible: throttle playback rate.
    // Counter can still run faster than this.
    const SOUND_MAX_PER_SEC = 60;
    const SOUND_MIN_GAP_MS = Math.floor(1000 / SOUND_MAX_PER_SEC);
    let lastSoundAt = 0;

    function playClick(){
      if (!soundOn) return;

      const now = performance.now();
      if (now - lastSoundAt < SOUND_MIN_GAP_MS) return;
      lastSoundAt = now;

      // Prefer WebAudio if running
      try{
        if (audioCtx && audioCtx.state === 'running'){
          const t = audioCtx.currentTime;
          const osc = audioCtx.createOscillator();
          const gain = audioCtx.createGain();
          osc.type = 'square';
          osc.frequency.setValueAtTime(1700, t);
          gain.gain.setValueAtTime(0.0001, t);
          gain.gain.exponentialRampToValueAtTime(0.12, t + 0.0012);
          gain.gain.exponentialRampToValueAtTime(0.0001, t + 0.012);
          osc.connect(gain);
          gain.connect(audioCtx.destination);
          osc.start(t);
          osc.stop(t + 0.013);
          return;
        }
      }catch(_e){
        // fall through
      }

      // Fallback: HTMLAudio
      try{
        if (!clickPool.length) buildClickPool();
        const a = clickPool[clickPoolIdx++ % clickPool.length];
        a.currentTime = 0;
        a.play().catch(() => {});
      }catch(_e){
        // ignore
      }
    }

    // Extra unlock hook for browsers that fire touch before pointer
    document.addEventListener('touchstart', () => { unlockAudioOnce(); }, { passive: true, once: true });

    // ====== Counter operations ======
    function inc(){
      if (value >= maxValue) return;
      setValue(value + 1);
      playClick();
    }

    function dec(){
      setValue(value - 1);
      playClick();
    }

    function reset(){
      setValue(0);
    }

    // ====== Hold-to-repeat (rAF batching) ======
    function makeHoldRepeater({ element, onTap, onTick }){
      let holdTimer = null;
      let holding = false;
      let pointerId = null;

      let rafId = null;
      let lastTs = 0;
      let carry = 0;

      function stop(){
        if (holdTimer) { clearTimeout(holdTimer); holdTimer = null; }
        if (rafId) { cancelAnimationFrame(rafId); rafId = null; }
        holding = false;
        pointerId = null;
        lastTs = 0;
        carry = 0;
      }

      function loop(ts){
        if (!holding) return;
        if (!lastTs) lastTs = ts;
        const dt = (ts - lastTs) / 1000;
        lastTs = ts;

        // batch ticks
        const target = ratePerSec * dt + carry;
        const whole = Math.floor(target);
        carry = target - whole;

        if (whole > 0){
          for (let i=0;i<whole;i++) onTick();
        }

        rafId = requestAnimationFrame(loop);
      }

      element.addEventListener('pointerdown', (e) => {
        unlockAudioOnce();

        pointerId = e.pointerId;
        element.setPointerCapture(pointerId);
        e.preventDefault();

        holdTimer = setTimeout(() => {
          holding = true;
          lastTs = 0;
          carry = 0;
          rafId = requestAnimationFrame(loop);
        }, HOLD_THRESHOLD_MS);
      }, { passive: false });

      element.addEventListener('pointerup', (e) => {
        if (pointerId !== e.pointerId) return;
        const wasHolding = holding;
        stop();
        if (!wasHolding) onTap();
      });

      element.addEventListener('pointercancel', (e) => {
        if (pointerId !== e.pointerId) return;
        stop();
      });

      element.addEventListener('lostpointercapture', () => {
        stop();
      });
    }

    makeHoldRepeater({ element: plusBtn, onTap: inc, onTick: inc });
    makeHoldRepeater({ element: minusBtn, onTap: dec, onTick: dec });

    // ====== Speed button ======
    // Tap => slower (reduce rate)
    // Hold (>1/3s) => ramp faster toward 1000/sec
    let speedHoldTimer = null;
    let speedRampTimer = null;
    let speedPointerId = null;
    let speedHolding = false;

    function clamp(n, min, max){
      return Math.max(min, Math.min(max, n));
    }

    function slowDown(){
      ratePerSec = clamp(Math.max(RATE_MIN, Math.floor(ratePerSec * 0.85)), RATE_MIN, RATE_MAX);
      updateHint();
    }

    function speedUp(){
      ratePerSec = clamp(Math.min(RATE_MAX, Math.ceil(ratePerSec * 1.15) + 1), RATE_MIN, RATE_MAX);
      updateHint();
    }

    function clearSpeedTimers(){
      if (speedHoldTimer) { clearTimeout(speedHoldTimer); speedHoldTimer = null; }
      if (speedRampTimer) { clearInterval(speedRampTimer); speedRampTimer = null; }
      speedHolding = false;
      speedPointerId = null;
    }

    speedBtn.addEventListener('pointerdown', (e) => {
      unlockAudioOnce();

      speedPointerId = e.pointerId;
      speedBtn.setPointerCapture(speedPointerId);
      e.preventDefault();

      speedHoldTimer = setTimeout(() => {
        speedHolding = true;
        speedRampTimer = setInterval(() => {
          speedUp();
        }, 85);
      }, HOLD_THRESHOLD_MS);
    }, { passive: false });

    speedBtn.addEventListener('pointerup', (e) => {
      if (speedPointerId !== e.pointerId) return;
      const wasHolding = speedHolding;
      clearSpeedTimers();
      if (!wasHolding) slowDown();
    });

    speedBtn.addEventListener('pointercancel', (e) => {
      if (speedPointerId !== e.pointerId) return;
      clearSpeedTimers();
    });

    speedBtn.addEventListener('lostpointercapture', () => {
      clearSpeedTimers();
    });

    // ====== Sound button ======
    soundBtn.addEventListener('click', (e) => {
      e.preventDefault();
      unlockAudioOnce();

      soundOn = !soundOn;
      soundIcon.textContent = soundOn ? 'üîä' : 'üîá';
      soundBtn.setAttribute('aria-label', soundOn ? 'Sound on' : 'Sound off');

      // small confirmation click when turning on
      if (soundOn) playClick();
    }, { passive: false });

    // ====== Reset ======
    resetBtn.addEventListener('click', (e) => {
      e.preventDefault();
      reset();
    }, { passive: false });

    // ====== Max slider ======
    maxSlider.addEventListener('input', () => {
      setMaxValue(parseInt(maxSlider.value, 10));
    });

    // ====== Prevent accidental double-tap zoom on iOS (best-effort) ======
    let lastTouchEnd = 0;
    document.addEventListener('touchend', (e) => {
      const now = Date.now();
      if (now - lastTouchEnd <= 250) e.preventDefault();
      lastTouchEnd = now;
    }, { passive: false });

    // ====== Tests (console) ======
    function runTests(){
      const assert = (cond, msg) => { if (!cond) throw new Error(`Test failed: ${msg}`); };

      // defaults
      assert(ratePerSec === 10, 'default rate is 10/sec');
      assert(maxValue === 10000, 'default max is 10000');

      // clamp to max
      setValue(100);
      setMaxValue(40);
      assert(value === 40, 'value clamps down when max decreases');

      // inc respects max
      setMaxValue(2);
      setValue(2);
      inc();
      assert(value === 2, 'inc does not exceed max');

      // speed bounds
      ratePerSec = 1;
      slowDown();
      assert(ratePerSec === 1, 'slowDown does not go below min');
      ratePerSec = 999;
      speedUp();
      assert(ratePerSec <= 1000, 'speedUp does not exceed max');

      // restore
      ratePerSec = 10;
      setMaxValue(10000);
      setValue(0);
      updateHint();

      console.log('All tests passed.');
    }

    // Initial render
    setMaxValue(10000);
    setValue(0);
    updateHint();
    runTests();
  </script>
</body>
</html>
