import React, { useEffect, useMemo, useRef, useState } from "react";

/**
 * FlipClock (seamless top-slide split‑flap, rounded blinking colon, flipping seconds)
 * - Hours:Minutes with a blinking round colon (two dots), vertically centered between HH and MM
 * - Seconds at smaller size to the right, with the same top‑slide flip
 * - Top‑only sequence: outgoing top slides down; incoming top slides down from above; panels never collide
 * - Swipe up (or click handle) to open settings: 24h/12h (AM/PM), font color, background color
 * - Settings persisted in localStorage
 */
export default function FlipClock() {
  const [now, setNow] = useState(new Date());

  // Settings (persisted)
  const [twelveHour, setTwelveHour] = useState(() => getStoredBool("flipclock:twelveHour", false));
  const [fgColor, setFgColor] = useState(() => getStored("flipclock:fg", "#111111"));
  const [bgColor, setBgColor] = useState(() => getStored("flipclock:bg", "#ffffff"));
  const [panelOpen, setPanelOpen] = useState(false);

  useEffect(() => {
    const id = setInterval(() => setNow(new Date()), 1000);
    return () => clearInterval(id);
  }, []);

  // Persist settings
  useEffect(() => store("flipclock:twelveHour", String(twelveHour)), [twelveHour]);
  useEffect(() => store("flipclock:fg", fgColor), [fgColor]);
  useEffect(() => store("flipclock:bg", bgColor), [bgColor]);

  const { hh, mm, ss, ampm } = useMemo(() => formatParts(now, twelveHour), [now, twelveHour]);

  // Swipe-up to open settings
  const startY = useRef<number | null>(null);
  const onTouchStart = (e: React.TouchEvent) => { startY.current = e.touches[0].clientY; };
  const onTouchEnd = (e: React.TouchEvent) => {
    const endY = e.changedTouches[0].clientY;
    if (startY.current !== null && startY.current - endY > 40) setPanelOpen(true);
    startY.current = null;
  };

  return (
    <div
      className="min-h-screen w-full flex items-center justify-center select-none"
      style={{ backgroundColor: bgColor, color: fgColor }}
      onTouchStart={onTouchStart}
      onTouchEnd={onTouchEnd}
    >
      {/* CSS only */}
      <style>{`
        @keyframes blink { 0%, 49% { opacity: 1; } 50%, 100% { opacity: 0; } }
        .blink { animation: blink 1s steps(1, end) infinite; }

        /* Digital-style font stack; uses Digital-7 if present */
        .digital7 {
          font-family: 'Digital-7', 'DS-Digital', 'Segment7', 'DSEG7 Classic', 'Seven Segment', ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
          letter-spacing: 0.04em;
        }

        /* Rounded colon dots */
        .colon-dot { width: 0.18em; height: 0.18em; border-radius: 9999px; display: block; background: currentColor; }

        /* === Split‑flap styles (seamless) === */
        .flip-digit { position: relative; display: inline-block; line-height: 1; overflow: hidden; }
        .abs-fill { position: absolute; inset: 0; }
        .flip-face { line-height: 1; }
        /* slight overlap to avoid hairline gap */
        .clip-top { clip-path: inset(0 0 50.1% 0); }
        .clip-bottom { clip-path: inset(49.9% 0 0 0); }

        .flip-layer { position: absolute; inset: 0; }
        .flip-upper { top: 0; }

        /* Slide-down sequence ONLY (no collision): */
        @keyframes slideOutTop { from { transform: translateY(0%);   } to { transform: translateY(100%); } }
        @keyframes slideInTop  { from { transform: translateY(-100%);} to { transform: translateY(0%);   } }
        .run-out-slide { animation: slideOutTop 0.26s ease-in forwards; }
        .run-in-slide  { animation: slideInTop  0.26s ease-out 0.14s forwards; }
      `}</style>

      <div className="flex items-center gap-3">
        <TimeGroup label="hours" value={hh} digitClass="text-[11vw] md:text-[9vw]" />
        <RoundedColon blink className="text-[11vw] md:text-[9vw]" />
        <TimeGroup label="minutes" value={mm} digitClass="text-[11vw] md:text-[9vw]" />
        <TimeGroup label="seconds" value={ss} digitClass="text-[6.2vw] md:text-[4.6vw]" groupClass="ml-2 opacity-80" />
        {twelveHour && (
          <span aria-label="am-pm" className="digital7 ml-2 align-baseline leading-none opacity-70 text-[4vw] md:text-[3vw]">
            {ampm}
          </span>
        )}
      </div>

      {/* Bottom handle for desktop users */}
      <button
        onClick={() => setPanelOpen(true)}
        className="fixed bottom-3 left-1/2 -translate-x-1/2 px-3 py-1 rounded-full text-xs/relaxed border border-current opacity-60 hover:opacity-100 transition"
        aria-label="Open settings"
      >
        Swipe up or click for settings
      </button>

      <SettingsPanel
        open={panelOpen}
        onClose={() => setPanelOpen(false)}
        twelveHour={twelveHour}
        onTwelveHour={setTwelveHour}
        fgColor={fgColor}
        bgColor={bgColor}
        onFgColor={setFgColor}
        onBgColor={setBgColor}
      />
    </div>
  );
}

function TimeGroup({ label, value, digitClass = "", groupClass = "" }: { label: string; value: string; digitClass?: string; groupClass?: string }) {
  return (
    <div className={`flex items-baseline gap-[0.4vw] ${groupClass}`} aria-label={label}>
      {[...value].map((ch, i) => (
        <FlipDigit key={label + i} value={ch} sizeClass={digitClass || "text-[11vw] md:text-[9vw]"} />
      ))}
    </div>
  );
}

function FlipDigit({ value, sizeClass }: { value: string; sizeClass: string }) {
  const [current, setCurrent] = useState(value);
  const [next, setNext] = useState<string | null>(null);
  const [anim, setAnim] = useState(false);

  useEffect(() => {
    if (value !== current) {
      setNext(value);
      const id = requestAnimationFrame(() => setAnim(true));
      const done = setTimeout(() => {
        setCurrent(value);
        setNext(null);
        setAnim(false);
      }, 500);
      return () => { cancelAnimationFrame(id); clearTimeout(done); };
    }
  }, [value, current]);

  return (
    <span className={`flip-digit digital7 ${sizeClass}`} aria-hidden>
      {/* sizing glyph so absolute layers have dimensions */}
      <span className="select-none opacity-0">8</span>

      {/* BASE FACES: show NEXT digit so incoming top can settle without touching */}
      <span className="flip-face clip-top abs-fill flex items-start justify-center">{next ?? current}</span>
      <span className="flip-face clip-bottom abs-fill flex items-end justify-center">{next ?? current}</span>

      {/* OUTGOING TOP: current top slides down */}
      {next !== null && (
        <span
          className={`flip-layer flip-upper clip-top ${anim ? 'run-out-slide' : ''} flex items-start justify-center`}
        >
          {current}
        </span>
      )}

      {/* INCOMING TOP: next top slides down from above, slightly delayed */}
      {next !== null && (
        <span
          className={`flip-layer flip-upper clip-top ${anim ? 'run-in-slide' : ''} flex items-start justify-center`}
        >
          {next}
        </span>
      )}
    </span>
  );
}

function RoundedColon({ blink = true, className = "" }: { blink?: boolean; className?: string }) {
  // Center vertically between HH and MM and keep it aligned with digit box height
  return (
    <span
      aria-hidden
      className={`${className} ${blink ? 'blink' : ''}`}
      style={{ display:'inline-flex', flexDirection:'column', alignItems:'center', justifyContent:'center', lineHeight:1, alignSelf:'center' }}
    >
      <span className="colon-dot" />
      <span className="colon-dot" style={{ marginTop: '0.28em' }} />
    </span>
  );
}

function SettingsPanel({
  open,
  onClose,
  twelveHour,
  onTwelveHour,
  fgColor,
  bgColor,
  onFgColor,
  onBgColor,
}: {
  open: boolean;
  onClose: () => void;
  twelveHour: boolean;
  onTwelveHour: (b: boolean) => void;
  fgColor: string;
  bgColor: string;
  onFgColor: (v: string) => void;
  onBgColor: (v: string) => void;
}) {
  // swipe down to close
  const startY = useRef<number | null>(null);
  const onTouchStart = (e: React.TouchEvent) => { startY.current = e.touches[0].clientY; };
  const onTouchEnd = (e: React.TouchEvent) => {
    const endY = e.changedTouches[0].clientY;
    if (startY.current !== null && endY - startY.current > 40) onClose();
    startY.current = null;
  };

  return (
    <div
      role="dialog"
      aria-modal="true"
      className={`fixed left-0 right-0 bottom-0 z-50 transition-transform duration-300 ease-out ${open ? "translate-y-0" : "translate-y-full"}`}
      onTouchStart={onTouchStart}
      onTouchEnd={onTouchEnd}
    >
      <div className="mx-auto max-w-xl w-full rounded-t-2xl shadow-xl border border-black/10 bg-white text-neutral-900">
        <div className="w-full flex justify-center py-2">
          <div className="h-1.5 w-12 rounded-full bg-neutral-300" />
        </div>
        <div className="px-5 pb-5 pt-2 space-y-4">
          <div className="flex items-center justify-between">
            <h2 className="text-base font-medium">Settings</h2>
            <button onClick={onClose} className="text-sm px-3 py-1 rounded border border-neutral-300 hover:bg-neutral-50">Close</button>
          </div>

          <fieldset className="space-y-2">
            <legend className="text-sm font-medium">Time format</legend>
            <label className="flex items-center gap-2 text-sm">
              <input type="radio" name="format" checked={!twelveHour} onChange={() => onTwelveHour(false)} />
              24-hour
            </label>
            <label className="flex items-center gap-2 text-sm">
              <input type="radio" name="format" checked={twelveHour} onChange={() => onTwelveHour(true)} />
              12-hour (show AM/PM)
            </label>
          </fieldset>

          <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
            <label className="text-sm flex items-center justify-between gap-3">
              <span>Font color</span>
              <input type="color" value={fgColor} onChange={(e) => onFgColor(e.target.value)} className="h-9 w-16 p-0 border rounded bg-transparent" aria-label="Choose font color" />
            </label>
            <label className="text-sm flex items-center justify-between gap-3">
              <span>Background</span>
              <input type="color" value={bgColor} onChange={(e) => onBgColor(e.target.value)} className="h-9 w-16 p-0 border rounded bg-transparent" aria-label="Choose background color" />
            </label>
          </div>
        </div>
      </div>
    </div>
  );
}

function pad2(n: number) { return n.toString().padStart(2, "0"); }

function formatParts(d: Date, twelveHour: boolean) {
  let h = d.getHours();
  const ampm = h >= 12 ? "PM" : "AM";
  if (twelveHour) { h = h % 12 || 12; }
  const hh = pad2(h);
  const mm = pad2(d.getMinutes());
  const ss = pad2(d.getSeconds());
  return { hh, mm, ss, ampm };
}

// ---- tiny localStorage helpers ----
function getStored(key: string, fallback: string) { try { const v = localStorage.getItem(key); return v ?? fallback; } catch { return fallback; } }
function getStoredBool(key: string, fallback: boolean) { try { const v = localStorage.getItem(key); return v ? v === 'true' : fallback; } catch { return fallback; } }
function store(key: string, val: string) { try { localStorage.setItem(key, val); } catch {} }

// ----------------------------
// Lightweight runtime tests
// ----------------------------
if (typeof window !== 'undefined') {
  // pad2 tests
  console.assert(pad2(0) === '00', 'pad2(0) should be 00');
  console.assert(pad2(7) === '07', 'pad2(7) should be 07');
  console.assert(pad2(12) === '12', 'pad2(12) should be 12');
  console.assert(pad2(59) === '59', 'pad2(59) should be 59');

  // formatParts tests (24h midnight/noon boundaries)
  const d0 = new Date('2025-01-01T00:00:00Z');
  const f0 = formatParts(new Date(d0.getTime()), false);
  console.assert(f0.hh.length === 2 && f0.mm === '00' && f0.ss === '00', 'formatParts 24h midnight');

  const dN = new Date('2025-01-01T12:00:00Z');
  const fN = formatParts(new Date(dN.getTime()), false);
  console.assert(fN.hh.length === 2 && fN.mm === '00' && fN.ss === '00', 'formatParts 24h noon');

  // formatParts tests (generic 24h)
  const d1 = new Date('2025-01-01T00:05:09Z');
  const fp1 = formatParts(new Date(d1.getTime()), false);
  console.assert(fp1.hh.length === 2 && fp1.mm === '05' && fp1.ss === '09', 'formatParts 24h basic');

  // formatParts tests (12h with AM/PM)
  const d2 = new Date('2025-01-01T13:08:04Z');
  const fp2 = formatParts(new Date(d2.getTime()), true);
  console.assert(fp2.ampm === 'PM' && fp2.hh.length === 2 && fp2.mm === '08' && fp2.ss === '04', 'formatParts 12h basic');

  const d3 = new Date('2025-01-01T00:00:00Z');
  const fp3 = formatParts(new Date(d3.getTime()), true);
  console.assert(fp3.ampm === 'AM' && fp3.hh === '12' && fp3.mm === '00' && fp3.ss === '00', 'formatParts 12h midnight shows 12');

  // Additional tests: noon in 12h and 23:59:59 rollover formatting
  const d4 = new Date('2025-01-01T12:34:56Z');
  const fp4 = formatParts(new Date(d4.getTime()), true);
  console.assert(fp4.ampm === 'PM' && fp4.hh === '12' && fp4.mm === '34' && fp4.ss === '56', 'formatParts 12h noon shows 12 PM');

  const d5 = new Date('2025-01-01T23:59:59Z');
  const fp5 = formatParts(new Date(d5.getTime()), false);
  console.assert(fp5.hh.length === 2 && fp5.mm === '59' && fp5.ss === '59', 'formatParts 24h 23:59:59');
}
